import re
import pandas as pd
from workflow.scripts.command_run import run_command


def run_CDHIT(input: str, output: str, threads: int, type_seq: str = "AA", identperc: float = 0.7):
    """Funtion that uses the run command function to easily run CD-HIT from the command line

    Args:
        input (str): Input path
        output (str): Output path
        threads (int): Number of threads
        type_seq (str, optional): Type of sequence to be clustered. Defaults to 'AA'
        identperc (float, optional): Minimum identity between sequences to be clustered. Defaults to 0.7
    """
    if type_seq == "AA":
        run_command(f'cd-hit`-i`{input}`-o`{output}`-c`{identperc}`-n`5`-M`16000`-d`0`-T`{threads}', sep = "`")
    else:
        run_command(f'cd-hit`-i`{input}`-o`{output}`-c`0.8`-n`5`-M`16000`-d`0`-T`{threads}', sep = "`")

def cdhit_parser(txtfile: str, ip: bool = False, kegg: bool = False) -> dict:
    """Receives a text file with a similar format as a FASTA file, and returns a dictionary with the number of the cluster as key and the UniProt ID's for the sequences inside each cluster as value.

    Args:
        txtfile (str): The name for the cluster file generated by CD-HIT

    Returns:
        dict: A dictionary with the number of the cluster as key and the UniProt ID's for the sequences inside each cluster as value.
    """
    handle = open(txtfile, "r")
    cluster = 0
    seqs_by_cluster = {}
    lines = handle.readlines()
    for line in lines:
        if line[0] == ">":
            cluster += 1
            seqs_by_cluster[cluster] = []
        else:
            try:
                if ip:
                    target_seq = re.findall(r">.*?\|", line)
                    clean = re.sub(r">", "", target_seq[0])
                    clean = re.sub(r"\|*", "", clean)
                if kegg:
                    target_seq = re.findall(r">.*\.\.\.", line)
                    clean = re.sub(r">", "", target_seq[0])
                    clean = re.sub(r"\.\.\..*", "", clean) 
                if ip == False and kegg == False:     
                    try:              
                        target_seq = re.findall(r"\|.*\|", line)
                        clean = re.sub(r"\|", "", target_seq[0])
                    except:
                        target_seq = re.findall(r">.*.", line)
                        clean = re.sub(r">", "", target_seq[0])
                        clean = re.sub(r"\.\.\..*", "", clean) 
            except:
                continue
            seqs_by_cluster[cluster].append(clean)
    return seqs_by_cluster

def counter(clstr_lst: dict, remove_single: bool = True, remove_duplicates: bool = False, tsv_ready: bool = False) -> dict:
    """Functions receives a dictionary with keys as the number of the cluster and UniProt sequences IDs as values and returns another dictionary
    with the number of sequences per cluster, with the option of removing single sequence clusters.

    Args:
        clstr_lst (dict): A dictionary with the number of the cluster as key and the UniProt ID's for the sequences inside each cluster as value.
        remove_single (bool, optional): Decides to remove single sequence clusters. Defaults to True.
        tsv_ready (bool, optional): Only works if remove_single is set to True, and makes a dicitionary of lists, ready to be saved as tsv. Defaults to False.
        remove_duplicates (bool, optional): Decides to remove duplicates from the clusters. Defaults to False.

    Returns:
        dict: A dictionary with the number of the cluster as key and the UniProt ID's for the sequences inside each cluster, as well as the size
        of that same cluster as value, in the form of tuple.
    """
    number_seqs_by_cluster = {}
    for k, v in clstr_lst.items():
        if remove_single:
            if len(v) > 1:
                if tsv_ready:
                    number_seqs_by_cluster[k] = v
                else:
                    number_seqs_by_cluster[k] = (v, len(v))
        else:
            number_seqs_by_cluster[k] = (v, len(v))
    set_number_seqs_by_cluster = {}
    if remove_duplicates:
        for k, v in number_seqs_by_cluster.items():
            if len(list(set(v))) == 1:
                continue
            else:
                set_number_seqs_by_cluster[k] = list(set(v))
    return set_number_seqs_by_cluster

def get_clustered_sequences(clust_dict: dict, path: str, inputed_seqs: str, input_IDs_list: list, db: str):
    """Wirtes an ouput FASTA file with the sequences from the input files that were clustered toghether 
    with CD-HIT.

    Args:
        clust_dict (dict): Dictionary from cdhit_parser function with number of cluster as key and every seq ID
        belonging to each cluster as value.
        path (str): Ouput path.
        inputed_seqs (str): Path for the initial input file.
        input_IDs_list (list): list of seq IDs from the input file (to facilitate).
    """
    # returns list of IDs from inputed FASTA sequences (entire ID)
    with open(inputed_seqs, "r") as rf:
        Lines = rf.readlines()
        for k, v in clust_dict.items():
            with open(f'{path}/{db}_cluster_{k}.fasta', "w") as wf:
                for x in v:
                    if x in input_IDs_list:
                        # try:
                            iterador = iter(Lines)
                            linha = next(iterador)
                            while linha is not None:
                                if x not in linha:
                                    linha = next(iterador, None)
                                    continue
                                elif x in linha:
                                    wf.write(linha)
                                    # print(linha)
                                    linha = next(iterador, None)
                                    # print(linha)
                                    while linha is not None and not linha.startswith(">"):
                                        wf.write(linha)
                                        linha = next(iterador, None)
                                        # print(linha)
                                elif x not in linha and linha.startswith(">"):
                                    break
                                linha = next(iterador, None)
                        # except:
                            # quit("File must be in Fasta format.")
                    else:
                        continue
            wf.close()
    rf.close()


# handle = cdhit_parser(snakemake.input[0])
# handle2 = counter(handle, tsv_ready=True, remove_duplicates=True)
# save_as_tsv(handle2, snakemake.output[0])
